"""docs_nav_audit.py

Checks `mkdocs.yml` navigation against files under `docs/` and writes a
markdown report to `dist/integrity/docs_nav_audit.md`.

Design notes:
- Core logic is in functions that operate on Python objects so tests don't
  require PyYAML to be installed. If PyYAML is available the script will use
  it to parse `mkdocs.yml` automatically; otherwise the user can call
  `flatten_nav()` with a pre-parsed nav structure.

Output contains three tables: Missing In Nav, Orphan, Broken. If any group
is empty the table contains a single row with "None" (acceptance criteria).
"""

from __future__ import annotations

import argparse
from pathlib import Path
from typing import Any, Iterable, List, Set, Tuple


def load_mkdocs_nav(mkdocs_path: Path) -> List:
    """Load the `nav` section from mkdocs.yml.

    Tries to import PyYAML. If not available raises RuntimeError to keep the
    function simple for callers who may prefer to pass a nav structure
    directly (tests do this).
    """
    try:
        import yaml  # type: ignore
    except Exception as exc:  # pragma: no cover - environment dependent
        raise RuntimeError("PyYAML is required to parse mkdocs.yml: %s" % exc)

    with mkdocs_path.open("r", encoding="utf-8") as f:
        data = yaml.safe_load(f)

    nav = data.get("nav", []) if isinstance(data, dict) else []
    return nav


def flatten_nav(nav: Iterable) -> Set[Path]:
    """Recursively flatten a parsed mkdocs `nav` list into a set of Paths.

    mkdocs nav is a list where each item is either a mapping (dict) or a
    string (shorthand). We collect string values that look like file paths
    (ending in .md).
    """
    paths: Set[Path] = set()

    def _walk(item: Any):
        if isinstance(item, str):
            p = Path(item.lstrip("/"))
            if p.suffix.lower() == ".md":
                # Keep relative path
                paths.add(Path(p))
            return
        if isinstance(item, dict):
            for key, val in item.items():
                # val can be a str or list
                _walk(val)
            return
        if isinstance(item, list):
            for v in item:
                _walk(v)

    # nav may be a list or dict; accept either
    _walk(nav)
    return paths


def collect_docs_files(docs_dir: Path) -> Set[Path]:
    """Collect markdown files under docs_dir, returning paths relative to docs_dir."""
    docs = set()
    for p in docs_dir.rglob("*.md"):
        try:
            rel = p.relative_to(docs_dir)
        except Exception:
            rel = p
        docs.add(rel)
    return docs


def generate_report(mkdocs_nav_paths: Set[Path], docs_files: Set[Path]) -> Tuple[List[str], List[str], List[str]]:
    """Return lists for missing_in_nav, orphan, broken.

    Definitions used here:
    - missing_in_nav: files present under docs/ but not referenced in nav
    - broken: files referenced in nav that do not exist under docs/
    - orphan: same as missing_in_nav (keeps parity with required output)
    """
    # Normalize both sets to posix string Paths for comparison
    nav_set = {Path(p).as_posix() for p in mkdocs_nav_paths}
    docs_set = {Path(p).as_posix() for p in docs_files}

    missing = sorted(docs_set - nav_set)
    broken = sorted(nav_set - docs_set)
    # For now, orphan is identical to missing; kept as separate concept for
    # future refinement.
    orphan = missing.copy()

    return missing, orphan, broken


def write_markdown_report(out_path: Path, missing: List[str], orphan: List[str], broken: List[str]) -> None:
    out_path.parent.mkdir(parents=True, exist_ok=True)
    lines = ["# Docs Nav Audit", "", "Generated by tools/docs_nav_audit.py", ""]

    def _section(title: str, items: List[str]):
        lines.append(f"## {title}")
        lines.append("")
        if not items:
            lines.append("None")
            lines.append("")
            return
        lines.append("| Path |")
        lines.append("| ---- |")
        for it in items:
            lines.append(f"| {it} |")
        lines.append("")

    _section("Missing In Nav", missing)
    _section("Orphan", orphan)
    _section("Broken", broken)

    out_path.write_text("\n".join(lines), encoding="utf-8")


def main(argv: List[str] | None = None) -> int:
    parser = argparse.ArgumentParser(description="Docs navigation audit against docs/ tree")
    parser.add_argument("--mkdocs", type=Path, default=Path("mkdocs.yml"), help="Path to mkdocs.yml")
    parser.add_argument("--docs-dir", type=Path, default=Path("docs"), help="Docs directory to scan")
    parser.add_argument(
        "--out",
        type=Path,
        default=Path("dist/integrity/docs_nav_audit.md"),
        help="Output markdown file",
    )
    args = parser.parse_args(argv)

    try:
        nav = load_mkdocs_nav(args.mkdocs)
    except Exception as exc:
        print("Warning: failed to parse mkdocs.yml with PyYAML:", exc)
        print("Attempting to extract nav heuristically by looking for 'nav:' lines")
        nav = _heuristic_nav_extract(args.mkdocs)

    nav_paths = flatten_nav(nav)
    docs_files = collect_docs_files(args.docs_dir)

    missing, orphan, broken = generate_report(nav_paths, docs_files)
    write_markdown_report(args.out, missing, orphan, broken)
    print(f"Wrote report to {args.out}")
    return 0


def _heuristic_nav_extract(mkdocs_path: Path) -> List:
    """A very small fallback to extract .md filenames from the nav: block.

    This is used only when PyYAML isn't available; it's best-effort and
    intentionally simple.
    """
    if not mkdocs_path.exists():
        return []
    lines = mkdocs_path.read_text(encoding="utf-8").splitlines()
    nav_lines: List[str] = []
    in_nav = False
    for ln in lines:
        stripped = ln.lstrip()
        if stripped.startswith("nav:"):
            in_nav = True
            continue
        if in_nav:
            if not ln.startswith(" ") and stripped and not stripped.startswith("-"):
                # end of nav block
                break
            # collect tokens that look like '- Key: file.md' or '- file.md'
            if ".md" in ln:
                nav_lines.append(ln.strip())
    # crude parse: extract parts after ':' or after '-'
    out = []
    for entry in nav_lines:
        if ':' in entry:
            _, rhs = entry.split(':', 1)
            rhs = rhs.strip().lstrip('-').strip()
            if rhs:
                out.append(rhs)
        else:
            part = entry.lstrip('-').strip()
            if part:
                out.append(part)
    return out


if __name__ == "__main__":
    raise SystemExit(main())
