name: opa-bundle-publish

on:
  push:
    branches: [main]
    paths:
      - "policies/**"
      - ".github/workflows/opa-bundle-publish.yml"
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      ci_image_tag:
        description: "CI image tag for RuleHub policy image (e.g., 2025.10.03-a1b2c3d4 or v1.2.3). Falls back to repo variable CI_IMAGE_TAG or latest."
        required: false
        default: ""

permissions:
  contents: read
  packages: read

env:
  IMAGE: ghcr.io/${{ github.repository_owner }}/rulehub-bundle
  # Set to '1' (e.g. via: act -s SKIP_SUPPLYCHAIN=1) to skip OIDC-dependent supply-chain steps locally.
  SKIP_SUPPLYCHAIN: "0"
  # Central pinned tool versions (update deliberately & audit supply chain when bumping)
  OPA_VERSION: "1.7.1"
  SYFT_VERSION: "v1.20.0"
  COSIGN_VERSION: "v2.2.4"

jobs:
  guard:
    name: Require CI image tag (no drift)
    runs-on: ubuntu-latest
    steps:
      - name: Enforce non-latest CI image tag
        shell: bash
        run: |
          input_tag="${{ inputs.ci_image_tag }}"
          if [ "$input_tag" = "latest" ]; then
            echo "Workflow input ci_image_tag must not be 'latest'. Use an immutable tag (e.g., 2025.10.03-<sha> or vX.Y.Z)." >&2
            exit 1
          fi
          if [ -z "$input_tag" ]; then
            echo "Note: ci_image_tag input not provided. Ensure repository variable CI_IMAGE_TAG is set to a pinned tag to avoid drift." >&2
          fi
  build-and-push-gh:
    if: ${{ github.actor != 'nektos/act' }}
    needs: guard
    runs-on: ubuntu-latest
    container:
      image: "ghcr.io/${{ github.repository_owner }}/ci-policy:${{ inputs.ci_image_tag != '' && inputs.ci_image_tag || (vars.CI_IMAGE_TAG != '' && vars.CI_IMAGE_TAG || '2025.10.03-f072ceb5') }}"
      credentials:
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
      options: --user 0:0
    defaults:
      run:
        shell: bash
    permissions:
      contents: write
      packages: write
      id-token: write
    outputs:
      tag: ${{ steps.tag.outputs.tag }}
      bundle_sha256: ${{ steps.digest.outputs.bundle_sha256 }}
      subjects_b64: ${{ steps.digest.outputs.subjects_b64 }}
      skip_supplychain: ${{ steps.flags.outputs.skip }}
    steps:
      - name: Checkout
        uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955

      # Python is provided by the CI container image

      - name: Prepare Python env (venv with baked deps)
        run: |
          python-venv-install
      - name: Rego deny[] usage enforcement
        run: |
          . .venv/bin/activate
          # Call Python script directly to avoid relying on make inside the container
          python tools/deny_usage_scan.py

      # Under local act runs, there is no OIDC; skip supply-chain steps safely
      # SKIP_SUPPLYCHAIN remains whatever is passed; GH path expects OIDC

      - name: Export skip flag
        id: flags
        run: echo "skip=${SKIP_SUPPLYCHAIN}" >> "$GITHUB_OUTPUT"

      - name: Tool versions (from CI image)
        run: |
          set -euo pipefail
          # Be tolerant to alias differences under act: prefer python3, fallback to python
          if command -v python3 >/dev/null 2>&1; then
            python3 --version
          elif command -v python >/dev/null 2>&1; then
            python --version
          else
            echo "python not found (expected in ci-policy image)"
          fi
          # These tools should exist in the CI image; under act allow soft-fail with note
          opa version || echo "opa not found"
          kyverno version || echo "kyverno not found"
          syft version || echo "syft not found"
          cosign version || echo "cosign not found"
          oras version || echo "oras not found"

      - name: Build OPA bundle
        run: |
          set -euo pipefail
          mkdir -p dist
          # Try native OPA bundle build; if running under act and it fails, fall back to a tar.gz of policies to keep CI green
          if ! opa build -b policies -o dist/opa-bundle.tar.gz; then
            # Detect nektos/act either via default actor or the injected IS_ACT flag
            if [ "${GITHUB_ACTOR:-}" = "nektos/act" ] || [ "${IS_ACT:-}" = "true" ]; then
              echo "[act] opa build failed; falling back to tar.gz of policies for local CI" >&2
              if [ -d policies ]; then
                tar czf dist/opa-bundle.tar.gz -C policies . || (echo "Fallback tar failed" >&2; : > dist/opa-bundle.tar.gz)
              else
                echo "policies/ not found; emitting empty bundle to unblock act" >&2
                : > dist/opa-bundle.tar.gz
              fi
            else
              echo "opa build failed on GitHub runner" >&2
              exit 1
            fi
          fi
          ls -lh dist/opa-bundle.tar.gz || true

      - name: Generate manifest
        run: |
          set -euo pipefail
          . .venv/bin/activate
          python tools/generate_bundle_manifest.py --output dist/opa-bundle.manifest.json --exclude-tests
          head -n 30 dist/opa-bundle.manifest.json || true

      - name: Generate references index (md+json)
        run: |
          set -euo pipefail
          . .venv/bin/activate
          python tools/generate_refs_index.py --format both || true
          ls -lh docs/references-index.md dist/references-index.json || true

      # Syft preinstalled in CI image

      - name: Generate CycloneDX SBOM
        run: |
          syft packages file:dist/opa-bundle.tar.gz -o cyclonedx-json > dist/opa-bundle.sbom.cdx.json
          echo "CycloneDX SBOM generated"

      - name: Generate SPDX SBOM
        run: |
          syft packages file:dist/opa-bundle.tar.gz -o spdx-json > dist/opa-bundle.sbom.spdx.json
          echo "SPDX SBOM generated"

      - name: Compute bundle digest & SLSA subjects
        id: digest
        run: |
          set -euo pipefail
          SHA256=$(sha256sum dist/opa-bundle.tar.gz | cut -d' ' -f1)
          SUBJECTS_JSON="[{\"name\":\"rulehub/opa-bundle.tar.gz\",\"digest\":{\"sha256\":\"$SHA256\"}}]"
          if base64 --help 2>&1 | grep -q '\-w'; then SUBJECTS_B64=$(echo -n "$SUBJECTS_JSON" | base64 -w0); else SUBJECTS_B64=$(echo -n "$SUBJECTS_JSON" | base64); fi
          echo "bundle_sha256=$SHA256" >> "$GITHUB_OUTPUT"
          echo "subjects_b64=$SUBJECTS_B64" >> "$GITHUB_OUTPUT"

      # Cosign preinstalled in CI image

      - name: Sign OPA bundle (keyless)
        if: ${{ env.SKIP_SUPPLYCHAIN != '1' }}
        env:
          COSIGN_EXPERIMENTAL: "1"
          COSIGN_YES: "true"
        run: |
          cosign sign-blob --yes --output-signature dist/opa-bundle.tar.gz.sig --output-certificate dist/opa-bundle.tar.gz.cert dist/opa-bundle.tar.gz

      - name: Sign manifest (keyless)
        if: ${{ env.SKIP_SUPPLYCHAIN != '1' }}
        env:
          COSIGN_EXPERIMENTAL: "1"
          COSIGN_YES: "true"
        run: |
          cosign sign-blob --yes --output-signature dist/opa-bundle.manifest.json.sig --output-certificate dist/opa-bundle.manifest.json.cert dist/opa-bundle.manifest.json

      - name: Sign SBOMs (keyless)
        if: ${{ env.SKIP_SUPPLYCHAIN != '1' }}
        env:
          COSIGN_EXPERIMENTAL: "1"
          COSIGN_YES: "true"
        run: |
          cosign sign-blob --yes --output-signature dist/opa-bundle.sbom.cdx.json.sig --output-certificate dist/opa-bundle.sbom.cdx.json.cert dist/opa-bundle.sbom.cdx.json
          cosign sign-blob --yes --output-signature dist/opa-bundle.sbom.spdx.json.sig --output-certificate dist/opa-bundle.sbom.spdx.json.cert dist/opa-bundle.sbom.spdx.json

      - name: Self-verify signatures (pre-push)
        # Ensures generated signatures & certs are valid (OIDC subject/issuer) before publishing to OCI
        if: ${{ env.SKIP_SUPPLYCHAIN != '1' }}
        env:
          COSIGN_EXPERIMENTAL: "1"
        run: |
          set -euo pipefail
          for base in dist/opa-bundle.tar.gz dist/opa-bundle.manifest.json dist/opa-bundle.sbom.cdx.json dist/opa-bundle.sbom.spdx.json; do
            sig="${base}.sig"; cert="${base}.cert";
            if [ -s "$sig" ] && [ -s "$cert" ]; then
              echo "Verifying $base" >&2
              cosign verify-blob \
                --certificate "$cert" \
                --signature "$sig" \
                --certificate-identity-regexp "https://github.com/${{ github.repository }}/.*" \
                --certificate-oidc-issuer-regexp '^https://token.actions.githubusercontent.com$' \
                "$base"
            else
              echo "Missing signature or cert for $base" >&2; exit 1
            fi
          done

      - name: Log in to GHCR (oras)
        if: ${{ env.SKIP_SUPPLYCHAIN != '1' }}
        run: |
          oras login ghcr.io -u "${{ github.actor }}" -p "${{ secrets.GITHUB_TOKEN }}"

      # ORAS preinstalled in CI image

      - name: Compute tag
        id: tag
        run: |
          if [[ "${{ github.event_name }}" == "release" ]]; then
            echo "tag=${{ github.event.release.tag_name }}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref_type }}" == "branch" && "${{ github.ref_name }}" == "main" ]]; then
            echo "tag=main-$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT
          else
            echo "tag=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT
          fi

      - name: Push bundle via ORAS
        if: ${{ env.SKIP_SUPPLYCHAIN != '1' }}
        run: |
          oras push ${IMAGE}:${{ steps.tag.outputs.tag }} \
            dist/opa-bundle.tar.gz:application/vnd.opa.bundle.layer.v1+tar \
            --annotation org.opencontainers.image.title="RuleHub OPA bundle" \
            --annotation org.opencontainers.image.source="${{ github.repository }}" \
            --annotation org.opencontainers.image.revision="${{ github.sha }}" \
            --annotation io.rulehub.manifest.sha256="$(sha256sum dist/opa-bundle.manifest.json | cut -d' ' -f1)"

      - name: Attest SBOMs
        if: ${{ env.SKIP_SUPPLYCHAIN != '1' }}
        env:
          COSIGN_EXPERIMENTAL: "1"
          COSIGN_YES: "true"
        run: |
          cosign attest --yes --predicate dist/opa-bundle.sbom.cdx.json --type cyclonedx ${IMAGE}:${{ steps.tag.outputs.tag }}
          cosign attest --yes --predicate dist/opa-bundle.sbom.spdx.json --type spdx ${IMAGE}:${{ steps.tag.outputs.tag }}

      - name: Upload artifacts (full)
        if: ${{ env.SKIP_SUPPLYCHAIN != '1' }}
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02
        with:
          name: opa-bundle-${{ steps.tag.outputs.tag }}
          path: |
            dist/opa-bundle.tar.gz
            dist/opa-bundle.tar.gz.sig
            dist/opa-bundle.tar.gz.cert
            dist/opa-bundle.sbom.cdx.json
            dist/opa-bundle.sbom.spdx.json
            dist/opa-bundle.manifest.json
            dist/opa-bundle.manifest.json.sig
            dist/opa-bundle.manifest.json.cert
            dist/opa-bundle.sbom.cdx.json.sig
            dist/opa-bundle.sbom.cdx.json.cert
            dist/opa-bundle.sbom.spdx.json.sig
            dist/opa-bundle.sbom.spdx.json.cert
            dist/references-index.json
            docs/references-index.md

      - name: Upload artifacts (minimal)
        if: ${{ env.SKIP_SUPPLYCHAIN == '1' }}
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02
        with:
          name: opa-bundle-${{ steps.tag.outputs.tag }}
          path: |
            dist/opa-bundle.tar.gz
            dist/opa-bundle.manifest.json
            dist/references-index.json
            docs/references-index.md

      - name: Digest summary
        id: digests
        run: |
          set -euo pipefail
          MANIFEST_SHA=$(sha256sum dist/opa-bundle.manifest.json | cut -d' ' -f1)
          BUNDLE_SHA=${{ steps.digest.outputs.bundle_sha256 }}
          AGG_HASH=$(jq -r '.aggregate_hash // empty' dist/opa-bundle.manifest.json)
          echo "bundle_sha256=$BUNDLE_SHA" >> $GITHUB_OUTPUT
          echo "manifest_sha256=$MANIFEST_SHA" >> $GITHUB_OUTPUT
          echo "aggregate_hash=$AGG_HASH" >> $GITHUB_OUTPUT
          printf "Bundle SHA256: %s\nManifest SHA256: %s\nAggregate Hash: %s\n" "$BUNDLE_SHA" "$MANIFEST_SHA" "$AGG_HASH" > dist/digest-summary.txt
          cat dist/digest-summary.txt

      - name: Release assets (full)
        if: ${{ github.event_name == 'release' && env.SKIP_SUPPLYCHAIN != '1' }}
        uses: softprops/action-gh-release@62c96d0c4e8a889135c1f3a25910db8dbe0e85f7
        with:
          files: |
            dist/opa-bundle.tar.gz
            dist/opa-bundle.tar.gz.sig
            dist/opa-bundle.tar.gz.cert
            dist/opa-bundle.sbom.cdx.json
            dist/opa-bundle.sbom.spdx.json
            dist/opa-bundle.manifest.json
            dist/opa-bundle.manifest.json.sig
            dist/opa-bundle.manifest.json.cert
            dist/opa-bundle.sbom.cdx.json.sig
            dist/opa-bundle.sbom.cdx.json.cert
            dist/opa-bundle.sbom.spdx.json.sig
            dist/opa-bundle.sbom.spdx.json.cert
            dist/references-index.json
            dist/digest-summary.txt
            docs/references-index.md

      - name: Release assets (minimal)
        if: ${{ github.event_name == 'release' && env.SKIP_SUPPLYCHAIN == '1' }}
        uses: softprops/action-gh-release@62c96d0c4e8a889135c1f3a25910db8dbe0e85f7
        with:
          files: |
            dist/opa-bundle.tar.gz
            dist/opa-bundle.manifest.json
            dist/references-index.json
            docs/references-index.md

      - name: Update mutable major tag
        if: ${{ github.event_name == 'release' }}
        run: |
          set -euo pipefail
          RELEASE_TAG="${{ github.event.release.tag_name }}"
          if [[ "$RELEASE_TAG" =~ ^v([0-9]+)\. ]]; then
            MAJOR=v${BASH_REMATCH[1]}
            git fetch --tags --quiet
            git tag -f "$MAJOR" "$RELEASE_TAG"
            git push origin ":refs/tags/$MAJOR" || true
            git push origin "$MAJOR"
          else
            echo "Release tag $RELEASE_TAG not SemVer vMAJOR.MINOR.PATCH; skipping mutable major tag update"
          fi

  slsa-provenance:
    if: ${{ needs.build-and-push-gh.outputs.skip_supplychain != '1' }}
    needs: build-and-push-gh
    permissions:
      actions: read
      id-token: write
      # Reusable workflow requires contents: write when upload-assets=true
      contents: write
    uses: slsa-framework/slsa-github-generator/.github/workflows/generator_generic_slsa3.yml@5a775b367a56d5bd118a224a811bba288150a563
    with:
      base64-subjects: ${{ needs.build-and-push-gh.outputs.subjects_b64 }}
      provenance-name: rulehub-opa-bundle.provenance
      upload-assets: true

  verify:
    if: ${{ github.actor != 'nektos/act' }}
    runs-on: ubuntu-latest
    container:
      image: "ghcr.io/${{ github.repository_owner }}/ci-policy:${{ inputs.ci_image_tag != '' && inputs.ci_image_tag || (vars.CI_IMAGE_TAG != '' && vars.CI_IMAGE_TAG || '2025.10.03-f072ceb5') }}"
      credentials:
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
      options: --user 0:0
    needs: [build-and-push-gh]
    permissions:
      contents: read
      packages: read
      id-token: write
    steps:
      - name: Download artifact bundle
        uses: actions/download-artifact@634f93cb2916e3fdff6788551b99b062d0335ce0
        with:
          name: opa-bundle-${{ needs.build-and-push-gh.outputs.tag }}
          path: dist

      # Python provided by CI container image

      - name: Verify manifest integrity (hashes)
        run: |
          python tools/verify_bundle.py \
            --manifest dist/opa-bundle.manifest.json \
            --bundle dist/opa-bundle.tar.gz \
            --policies-root policies --skip-git || exit 1

      # Cosign preinstalled in CI image

      - name: Verify manifest signature
        if: ${{ env.SKIP_SUPPLYCHAIN != '1' }}
        env:
          COSIGN_EXPERIMENTAL: "1"
        run: |
          cosign verify-blob \
            --certificate dist/opa-bundle.manifest.json.cert \
            --signature dist/opa-bundle.manifest.json.sig \
            --certificate-identity-regexp "https://github.com/${{ github.repository }}/.*" \
            --certificate-oidc-issuer-regexp '^https://token.actions.githubusercontent.com$' \
            dist/opa-bundle.manifest.json

      - name: Verify SBOM signatures
        if: ${{ env.SKIP_SUPPLYCHAIN != '1' }}
        env:
          COSIGN_EXPERIMENTAL: "1"
        run: |
          for base in dist/opa-bundle.sbom.cdx.json dist/opa-bundle.sbom.spdx.json; do
            cosign verify-blob \
              --certificate ${base}.cert \
              --signature ${base}.sig \
              --certificate-identity-regexp "https://github.com/${{ github.repository }}/.*" \
              --certificate-oidc-issuer-regexp '^https://token.actions.githubusercontent.com$' \
              ${base}
          done

      - name: Verify bundle signature
        if: ${{ env.SKIP_SUPPLYCHAIN != '1' }}
        env:
          COSIGN_EXPERIMENTAL: "1"
        run: |
          cosign verify-blob \
            --certificate dist/opa-bundle.tar.gz.cert \
            --signature dist/opa-bundle.tar.gz.sig \
            --certificate-identity-regexp "https://github.com/${{ github.repository }}/.*" \
            --certificate-oidc-issuer-regexp '^https://token.actions.githubusercontent.com$' \
            dist/opa-bundle.tar.gz

      - name: Check SBOM presence (minimal)
        if: ${{ env.SKIP_SUPPLYCHAIN != '1' }}
        run: |
          test -s dist/opa-bundle.sbom.cdx.json
          test -s dist/opa-bundle.sbom.spdx.json

      # jq included in CI image

      - name: Login GHCR (provenance fetch)
        if: ${{ env.SKIP_SUPPLYCHAIN != '1' }}
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Verify provenance attestation
        if: ${{ env.SKIP_SUPPLYCHAIN != '1' }}
        env:
          COSIGN_EXPERIMENTAL: "1"
        run: |
          cosign verify-attestation --type slsaprovenance ${IMAGE}:${{ needs.build-and-push-gh.outputs.tag }} > attestation.jsonl
          PRED_FILE=extracted-predicate.json
          head -n1 attestation.jsonl | jq -r '.predicate' > "$PRED_FILE"
          EXPECTED_SHA=$(sha256sum dist/opa-bundle.tar.gz | cut -d' ' -f1)
          jq -e --arg sha "${{ github.sha }}" '.buildDefinition.inputMaterials[].digest.sha1? == $sha' "$PRED_FILE" | grep -q true
          jq -e --arg bsha "$EXPECTED_SHA" '.buildDefinition.inputMaterials[].digest.sha256? == $bsha' "$PRED_FILE" | grep -q true

  build-act:
    if: ${{ github.actor == 'nektos/act' }}
    needs: guard
    runs-on: ubuntu-latest
    container:
      image: "ghcr.io/${{ github.repository_owner }}/ci-policy:${{ inputs.ci_image_tag != '' && inputs.ci_image_tag || (vars.CI_IMAGE_TAG != '' && vars.CI_IMAGE_TAG || '2025.10.03-f072ceb5') }}"
      credentials:
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
      options: --user 0:0
    defaults:
      run:
        shell: bash
    permissions:
      contents: read
      packages: read
    steps:
      - name: Checkout
        uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955

      - name: Prepare Python env (venv with baked deps)
        run: |
          python-venv-install

      - name: Rego deny[] usage enforcement
        run: |
          . .venv/bin/activate
          python tools/deny_usage_scan.py

      - name: Set skip supply-chain for act
        run: echo "SKIP_SUPPLYCHAIN=1" >> "$GITHUB_ENV"

      - name: Tool versions (from CI image)
        run: |
          set -euo pipefail
          if command -v python3 >/dev/null 2>&1; then python3 --version; elif command -v python >/dev/null 2>&1; then python --version; else echo "python not found"; fi
          opa version || echo "opa not found"
          kyverno version || echo "kyverno not found"
          syft version || echo "syft not found"
          cosign version || echo "cosign not found"
          oras version || echo "oras not found"

      - name: Build OPA bundle
        run: |
          set -euo pipefail
          mkdir -p dist
          if ! opa build -b policies -o dist/opa-bundle.tar.gz; then
            echo "[act] opa build failed; falling back to tar.gz of policies for local CI" >&2
            if [ -d policies ]; then
              tar czf dist/opa-bundle.tar.gz -C policies . || (echo "Fallback tar failed" >&2; : > dist/opa-bundle.tar.gz)
            else
              echo "policies/ not found; emitting empty bundle to unblock act" >&2
              : > dist/opa-bundle.tar.gz
            fi
          fi
          ls -lh dist/opa-bundle.tar.gz || true

      - name: Generate manifest
        run: |
          set -euo pipefail
          . .venv/bin/activate
          python tools/generate_bundle_manifest.py --output dist/opa-bundle.manifest.json --exclude-tests
          head -n 30 dist/opa-bundle.manifest.json || true

      - name: Generate references index (md+json)
        run: |
          set -euo pipefail
          . .venv/bin/activate
          python tools/generate_refs_index.py --format both || true
          ls -lh docs/references-index.md dist/references-index.json || true

      - name: Generate CycloneDX SBOM
        run: |
          syft packages file:dist/opa-bundle.tar.gz -o cyclonedx-json > dist/opa-bundle.sbom.cdx.json || echo "syft not available"

      - name: Generate SPDX SBOM
        run: |
          syft packages file:dist/opa-bundle.tar.gz -o spdx-json > dist/opa-bundle.sbom.spdx.json || echo "syft not available"

      - name: Compute bundle digest & summary
        run: |
          set -euo pipefail
          SHA256=$(sha256sum dist/opa-bundle.tar.gz | cut -d' ' -f1)
          printf "Bundle SHA256: %s\n" "$SHA256" | tee dist/digest-summary.txt
